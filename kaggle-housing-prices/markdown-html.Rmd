---
title: 'Regression techniques with R data.table and h2o machine learning'
date: "`r format(Sys.Date())`"
author: "Bart Boerman"
output:
  html_document:
    theme: lumen
    toc: true
    number_sections: true
    font-family: Open Sans, sans-serif
    font-import: https://fonts.googleapis.com/css?family=Open+Sans
    code_folding: show
    highlight: tango
editor_options: 
  chunk_output_type: console
---
<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
  }
td {  /* Table  */
  font-size: 12px;
}
h1, .h1, h2, .h2, h3, .h3 {
    margin-top: 10.5px;
    margin-bottom: 10.5px;
}
h1.title {
  font-size: 28px;
  color: #7db956;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: #3e4a52;
}
h2 { /* Header 2 */
    font-size: 18px;
  color: #3e4a52;
}
h3 { /* Header 3 */
  font-size: 14px;
  color: #3e4a52;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
th.sorting { /* DT column headers  */
    text-align: left;
}
</style>
# Introduction

## Version

**Raw inital version**.

## Goal

Exploratory analyis and machine learning modal for predicting 
housing prices in competition ["House Prices: Advanced Regression Techniques"](https://www.kaggle.com/c/house-prices-advanced-regression-techniques). The aim is to predict house prices based on the provided data:

- **train.csv**,data for training our model 
- **test.csv**, data used to see how well our model performs on unseen data

In addition I want to gain and share some basic knowledge of

- data wrangling and analysis with data.table
- machine learning with h2o
- stacking with h2o

## Required libraries

- **knitr**, used to create this document 
- **data.table**, fast data wrangling with R
- **h2o**, machine learning algorithmes and more from h2o.ai
- **psych**, descriptive analytics, skewness and kurtosis
- **caret**, (near) zero variance
```{r setup, message=FALSE, warning=FALSE, paged.print=FALSE}
###################################################################
#### Dependencies                                              ####
###################################################################
require(knitr)      ## a general-purpose programming engine
knitr::opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
require(DT)         ##  display data in html tables
require(data.table) ## fast data wrangling and analysis
require(psych)      ## descriptive statistics, skewness and kurtosis
require(caret)      ## (near) zero variance
```

# Get data into R

```{r}
###################################################################
#### Get data                                                  ####
###################################################################
train.dt <- fread(input = "train.csv", 
                  sep = ",", 
                  nrows = -1,
                  header = T,
                  na.strings=c("NA","N/A","null"),
                  stringsAsFactors = F,
                  check.names = T,
                  strip.white = T,
                  blank.lines.skip = T,
                  data.table = T
) 
test.dt <- fread(input = "test.csv", 
                 sep = ",", 
                 nrows = -1,
                 header = T,
                 na.strings=c("NA","N/A","null"),
                 stringsAsFactors = F,
                 check.names = T,
                 strip.white = T,
                 blank.lines.skip = T,
                 data.table = T
) 
## Create one data set for feature engineering. 
train.dt[, dataPartition:="train"]
test.dt[, SalePrice:=as.integer(NA)] 
test.dt[, dataPartition:="test"]
full.dt <- rbindlist(list(train.dt, test.dt), use.names = F, fill = F)
```

# Data dictionary

## Variables in raw data

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
## Data types
variableTypes.df <- cbind(as.data.frame(names(full.dt)),as.data.frame(sapply(full.dt, class)))
names(variableTypes.df) <- c("variable","type")
datatable(variableTypes.df, rownames = F, 
          caption = "List of variables with data type", 
          options = list(pageLength = 8)) ## Interactive HTML table
```

## Definitions

```{r}
## Numeric, square footage
variablesSquareFootage <- c(
  "LotFrontage", 		## Linear feet of street connected to property 
  "LotArea",    		## Lot size in square feet
  "MasVnrArea",  		## Masonry veneer area in square feet
  "BsmtFinSF1",		  ## Type 1 finished square feet	
  "BsmtFinSF2",		  ## Type 2 finished square feet
  "BsmtUnfSF",		  ## Unfinished square feet of basement area
  "TotalBsmtSF", 		## Total square feet of basement area
  "FirstFlrSF",		  ## First Floor square feet
  "SecondFlrSF",	  ## Second floor square feet
  "LowQualFinSF", 	## Low quality finished square feet (all floors)
  "GrLivArea", 		  ## Above grade (ground) living area square feet
  "GarageArea",     ## Size of garage in square feet
  "WoodDeckSF",     ## Wood deck area in square feet
  "OpenPorchSF",    ## Open porch area in square feet  
  "EnclosedPorch",  ## Enclosed porch area in square feet 
  "ThreeSsnPorch",  ## Three season porch area in square feet 
  "ScreenPorch",    ## Screen porch area in square feet
  "PoolArea" 		    ## Pool area in square feet
)
## Counts, a house has n of something
variablesCounts <- c(
  "BsmtFullBath",		## Basement full bathrooms
  "BsmtHalfBath",		## Basement half bathrooms
  "FullBath",			  ## Full bathrooms above grade
  "HalfBath",			  ## Half baths above grade
  "BedroomAbvGr",		## Bedrooms above grade (does NOT include basement bedrooms)
  "KitchenAbvGr",		## Kitchens above grade
  "TotRmsAbvGrd",		## Total rooms above grade (does not include bathrooms)
  "Fireplaces",		  ## Number of fireplaces
  "GarageCars"     	## Size of garage in car capacity
)
## Values
variablesValues <- c(
  "MiscVal",        ## $ Value of miscellaneous feature
  "SalePrice"       ## $ Price paid
)
## Factors
variablesFactor <- colnames(full.dt)[which(as.vector(full.dt[,sapply(full.dt, class)]) == "character")]
variablesFactor <- c(variablesFactor,
                     "MSSubClass",     ## Identifies the type of dwelling involved in the sale
                     "OverallQual",    ## Rates the overall material and finish of the house
                     "OverallCond",     ## Rates the overall condition of the house
                     ## Import year and months as integers.
                     #"MoSold",           
                     "YrSold"        
                     #"YearRemodAdd"   
                     #"YearBuilt",     
                     #"GarageYrBlt"    
)
```

## Data engineering

```{r}
###################################################################
#### Data engineering                                          ####
###################################################################
## In R first character can not be a number in variable names
setnames(full.dt, c("X1stFlrSF","X2ndFlrSF","X3SsnPorch"), c("FirstFlrSF","SecondFlrSF","ThreeSsnPorch"))
## Set columns to numeric
changeColType <- c(variablesSquareFootage, variablesCounts, variablesValues)
full.dt[,(changeColType):= lapply(.SD, as.numeric), .SDcols = changeColType]
## Set columns to factor
changeColType <- variablesFactor
full.dt[,(changeColType):= lapply(.SD, as.factor), .SDcols = changeColType]
###################################################################
#### Ordered factors                                           ####
###################################################################
## OverallQual, rates the overall material and finish of the house
full.dt[,OverallQual:=ordered(OverallQual, levels = c(1:10))]
## OverallCond, rates the overall condition of the house
full.dt[,OverallCond:=ordered(OverallCond, levels = c(1:10))]
## KitchenQual, kitchen quality
full.dt[,KitchenQual:=ordered(KitchenQual, levels = c("Po","Fa","TA","Gd","Ex"))]
## GarageFinish (contains NA's)
full.dt[,GarageFinish:=ordered(GarageFinish, levels = c("None","Unf","RFn","Fin"))]
## ExterQual, evaluates the quality of the material on the exterior  
full.dt[,ExterQual:=ordered(ExterQual, levels = c("Po","Fa","TA","Gd","Ex"))]
## ExterCond, evaluates the present condition of the material on the exterior
full.dt[,ExterCond:=ordered(ExterCond, levels = c("Po","Fa","TA","Gd","Ex"))]
## BsmtQual (contains NA's), evaluates the height of the basement
full.dt[,BsmtQual:=ordered(BsmtQual, levels = c("None","Po","Fa","TA","Gd","Ex"))]
## BsmtCond (contains NA's), evaluates the general condition of the basement
full.dt[,BsmtCond:=ordered(BsmtCond, levels = c("None","Po","Fa","TA","Gd","Ex"))]
## BsmtExposure (contains NA's), refers to walkout or garden level walls
full.dt[,BsmtExposure:=ordered(BsmtExposure, levels = c("None","No","Mn","Av","Gd"))]
## BsmtFinType1 (contains NA's), rating of basement finished area
full.dt[,BsmtFinType1:=ordered(BsmtFinType1, levels = c("None","Unf","LwQ","Rec","BLQ","ALQ","GLQ"))]
## FireplaceQu (contains NA's), fireplace quality
full.dt[,FireplaceQu:=ordered(FireplaceQu, levels = c("None","Po","Fa","TA","Gd","Ex"))]
## Electrical
full.dt[,Electrical:=ordered(Electrical, levels = c("FuseP","Mix","FuseF","FuseA","SBrkr"))]
## Did not (yet) convert all possible factors to hierarchical.
## Ordered factors are not supported by h2o, Let's convert them into integers during pre-processing. Lowest level will be 1 etc.
```

# Descriptive statistics

## statisticts

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
###################################################################
#### Descriptive statistics                                    ####
###################################################################
## statisticts
descStats.df <- describe(full.dt[, c(variablesSquareFootage,variablesValues), with = FALSE]) ## from psych package 
datatable(round(descStats.df,2), rownames = T,
          caption = "Descriptive statistics", 
          options = list(pageLength = 8)) ## Interactive HTML table
## na values
countIsNA <- sapply(full.dt,function(x)sum(is.na(x)))
countIsNA.df <- data.frame(countIsNA)
countIsNA.df <- data.frame(variableName = row.names(countIsNA.df), countIsNA.df,row.names = NULL)
countIsNA.df <- countIsNA.df[countIsNA >0,]
datatable(countIsNA.df, rownames = T, 
          caption = "Variables with missing values", 
          options = list(pageLength = 8)) ## Interactive HTML table
## zero variance
zeroVarianceVariables.df <- nearZeroVar(full.dt, names = T, saveMetrics = T,
                                        foreach = T, allowParallel = T)

datatable(round(subset(zeroVarianceVariables.df, nzv == TRUE, 
                       select =     c("freqRatio","percentUnique")),2), 
          rownames = T,
          caption = "Variables with (near) zero variance", 
          options = list(pageLength = 8)) ## Interactive HTML table
```

# Data Cleansing

## Impute missing values

```{r}
###################################################################
#### Impute missing values                                     ####
###################################################################
## Kitchen
full.dt[is.na(KitchenQual), KitchenQual := "TA" ] ## One record, set to Typical
## Garage
full.dt[is.na(GarageFinish) & GarageType == "Detchd", ':=' (GarageFinish = "Fin",
                                                        GarageCars = 1,
                                                        GarageArea = 360,
                                                        GarageYrBlt = YearRemodAdd,
                                                        GarageQual = "TA",
                                                        GarageCond = "TA")] 
full.dt[is.na(GarageFinish), GarageFinish := "None"]
full.dt[is.na(GarageQual), GarageQual := "None"]
full.dt[is.na(GarageCond), GarageCond := "None"]
full.dt[is.na(GarageType), GarageType := "None"]
full.dt[is.na(GarageYrBlt), GarageYrBlt := 0]
## Basement
full.dt[is.na(BsmtExposure) & BsmtFinType1 == "Unf" , BsmtExposure := "No"]
full.dt[is.na(BsmtExposure), BsmtExposure := "None"]
full.dt[is.na(BsmtQual) & BsmtFinType1 == "Unf" , BsmtQual := "TA"]
full.dt[is.na(BsmtQual), BsmtQual := "None"]
full.dt[is.na(BsmtCond), BsmtCond := "None"]
full.dt[is.na(BsmtFinType1), BsmtFinType1 := "None"]
full.dt[is.na(BsmtFinType2) & BsmtFinSF2 > 0, BsmtFinType2 := "Unf"]
full.dt[is.na(BsmtFinType2), BsmtFinType2 := "None"]
full.dt[is.na(BsmtFinSF1),':=' (BsmtFinSF1 = 0, BsmtFinSF2 = 0, BsmtUnfSF = 0, TotalBsmtSF = 0)] 
full.dt[is.na(BsmtFullBath),':=' (BsmtFullBath = 0, BsmtHalfBath = 0)] 
## FireplaceQu  
full.dt[is.na(FireplaceQu), FireplaceQu := "None"]
## LotFrontage
full.dt[, LotFrontage := replace(LotFrontage, is.na(LotFrontage), median(LotFrontage, na.rm=TRUE)), by=.(Neighborhood)]
## MSZoning
## RL for missing MSZoning in Mitchel because GrLivArea is greater then max of RM
## Not sure (yet) for missing MSZoning in IDOTRR. RM is most common in IDOTRR but might be wrong
full.dt[is.na(MSZoning) & Neighborhood == "Mitchel", MSZoning := "RL"]
full.dt[is.na(MSZoning) & Neighborhood == "IDOTRR", MSZoning  := "RM"]
## Electrical
## Most common value for neighborhood Timber is SBrkr
full.dt[is.na(Electrical) , Electrical  := "SBrkr"]
## Exterior
## Most common for neighborhood and large total square footage is "MetalSd"
full.dt[is.na(Exterior1st),':=' (Exterior1st = "MetalSd",Exterior2nd = "MetalSd")]
## MasVnrType and MasVnrArea. Taking the easy way out here
full.dt[is.na(MasVnrType),':=' (MasVnrType = "None", MasVnrArea = 0)]
## SaleType
full.dt[is.na(SaleType), SaleType := "WD"]
## Functional
full.dt[is.na(Functional), Functional := "Typ"]
## MiscFeature
full.dt[is.na(MiscFeature), MiscFeature := "None"]
```

## Other operations

```{r}
## Typo in GarageYrBlt
full.dt[GarageYrBlt == 2207, GarageYrBlt:= 2007]
```


